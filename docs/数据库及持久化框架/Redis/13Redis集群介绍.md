### Redis集群介绍

Redis集群是一个由多个主从节点群组成的分布式服务集群，具有复制、高可用性和分片特性。它能够在多个节点之间分配数据和负载，并在某些节点出现故障时保持数据的可用性。

![image-20241014143735844](http://image.wangxiaohuan.com/blog/image/202410141437518.png)

### Redis集群的原理

Redis集群的设计遵循水平扩展、负载均衡、数据分散、数据副本和自动故障转移等原则。通过智能路由算法将请求分配到不同的节点上，Redis集群提高了并发性和系统可用性。同时，它将相同键值的数据分散存储在不同节点上，最大限度地提高了可用性，并优化了网络带宽。

在Redis集群中，每个节点都拥有自己的数据副本和负载均衡机制，可以根据需要进行动态扩容和缩容。当一个客户端连接到Redis集群时，它会向其中的一个或多个数据节点发送请求，并在获取响应后关闭连接。这种设计使得Redis集群能够高效地处理大量数据和请求。

### 槽位（Slot）

槽位是Redis集群中实现数据分片的关键概念。Redis集群将整个数据库分为16384个槽位，每个槽位可以存储一部分键值对。通过槽位，Redis集群能够将数据分散存储在多个节点上，实现负载均衡和快速查询。

当一个客户端向Redis集群发送请求时，集群会根据key的哈希值计算出对应的槽位，然后将请求路由到负责该槽位的节点上。如果客户端尝试访问一个不存在的key，集群也会根据哈希值计算出对应的槽位，并返回该槽位所在的节点信息。

![image-20241014143904676](http://image.wangxiaohuan.com/blog/image/202410141439878.png)

Redis集群采用了虚拟槽（slot）的概念来管理数据分片。以下是几种常见的分片算法：

- **哈希求余算法**：该算法通过哈希函数将一个key映射为一个整数，然后对数组的长度进行取余操作得到对应数组下标，即保存位置。但这种方法在扩容时会导致大量数据迁移。
- **一致性哈希算法**：为了降低数据迁移的开销，业界提出了“一致性哈希算法”。它将0~2^32-1这个数据空间映射到一个圆环上，数据按照顺时针方向增长。然后，根据key的哈希值在圆环上找到对应的分片位置。这种方法在扩容时只需将部分数据迁移到新分片上，但存在数据倾斜的问题。

> [!IMPORTANT]
>
> **容错性**
>
> 假设Node C宕机，可以看到此时对象A、B、D不会受到影响。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据且这些数据会转移到D进行存储。
>
> <img src="http://image.wangxiaohuan.com/blog/image/202410141442565.png" alt="image-20241014144243152" style="zoom:50%;" />
>
> **扩展性**
>
> 数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，不会导致hash取余全部数据重新洗牌。
>
> <img src="http://image.wangxiaohuan.com/blog/image/202410141445709.png" alt="image-20241014144500905" style="zoom:50%;" />
>
> **Hash环的数据倾斜问题**
>
> 一致性Hash算法在服务**节点太少时**，容易因为节点分布不均匀而造成**数据倾斜**（被缓存的对象大部分集中缓存在某一台服务器上）问题，
>
> 例如系统中只有两台服务器：
>
> <img src="http://image.wangxiaohuan.com/blog/image/202410141446657.png" alt="image-20241014144615551" style="zoom:50%;" />



- **哈希槽分区算法**：这是Redis真正采取的算法。它将哈希求余算法和一致性哈希算法结合了起来，使用CRC16校验函数对key进行哈希计算，然后对16384取模来决定放置哪个槽。Redis集群的槽位总数为16384个，每个节点负责存储一部分槽位和数据。

> [!TIP]
>
> Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。但为什么哈希槽的数量是16384（2^14）个呢？
>
> CRC16算法产生的hash值有16bit，该算法可以产生2^16=65536个值。换句话说值是分布在0~65535之间，有更大的65536不用为什么只用16384就够？作者在做mod运算的时候，为什么不mod65536，而选择mod16384？ HASH_SLOT = CRC16(key) mod 65536为什么没启用
>
> 正常的心跳数据包带有节点的完整配置，可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。
>
> 这意味着它们包含原始节点的插槽配置，该节点使用2k的空间和16k的插槽，但是会使用8k的空间（使用65k的插槽）。
>
> 同时，由于其他设计折衷，Redis集群不太可能扩展到1000个以上的主节点。
>
> 因此16k处于正确的范围内，以确保每个主机具有足够的插槽，最多可容纳1000个矩阵，但数量足够少，可以轻松地将插槽配置作为原始位图传播。请注意，在小型群集中，位图将难以压缩，因为当N较小时，位图将设置的slot / N位占设置位的很大百分比。
>
> (1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。
>
> 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb 
>
> 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为16384时，这块的大小是: 16384÷8÷1024=2kb 
>
> 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。
>
>  
>
> (2)redis的集群主节点数量基本不可能超过1000个。
>
> 集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。
>
> 
>
> (3)槽位越小，节点少的情况下，压缩比高，容易传输
>
> Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。 





### 分片

分片是Redis集群中实现数据水平扩展的关键技术。通过将整个数据库分为多个分片，Redis集群能够将数据分散存储在多个节点上，从而提高系统的存储能力和并发处理能力。

在Redis集群中，每个分片都对应一部分槽位和数据。当需要扩容或缩容时，可以通过添加或删除节点来调整分片数量。由于每个节点都保存了槽位和数据的映射关系，因此可以很方便地进行数据迁移和负载均衡。